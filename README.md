# DesignPatterns
Design Patterns: Python examples

### **ПОРОЖДАЮЩИЕ (Как правильно "рождать" объекты)**

Эти паттерны отвечают на вопрос **"КАК создать объект?"**, делая процесс гибким, удобным и контролируемым.

1.  **Singleton (Одиночка)**
    *   **Суть:** Гарантирует, что у класса есть **только один экземпляр**, и предоставляет к нему глобальную точку доступа.
    *   **Простая аналогия:** **Капитан корабля**. На корабле может быть только один капитан. Когда нужно принять решение, все обращаются именно к нему, а не ищут нового.
    *   **Зачем?** Когда нужен единый контроль: настройки приложения, подключение к базе данных, логгер.

2.  **Factory Method (Фабричный метод)**
    *   **Суть:** Определяет **интерфейс** для создания объекта, но позволяет подклассам решать, какой именно класс создавать.
    *   **Простая аналогия:** **Строительная компания.** У вас есть общий план дома (интерфейс). Компания-застройщик (подкласс) решает, какие конкретно материалы и бригады использовать для его постройки (конкретный объект).
    *   **Зачем?** Когда заранее неизвестно, объект какого именно подкласса понадобится создать. Делает код независимым от конкретных классов.

3.  **Abstract Factory (Абстрактная фабрика)**
    *   **Суть:** Создает **семейства** связанных объектов, не привязываясь к их конкретным классам.
    *   **Простая аналогия:** **Мебельный гарнитур.** Вы идете не за отдельным стулом, а в магазин "Современный стиль" (абстрактная фабрика). Там вы получаете *весь комплект*: современный диван, современный стол, современный шкаф (семейство объектов). В магазине "Классический стиль" будут другие, но тоже гармонирующие между собой предметы.
    *   **Зачем?** Когда система должна быть независима от того, как создаются и компонуются её продукты, и должна работать с целыми семействами.

4.  **Builder (Строитель)**
    *   **Суть:** Позволяет создавать сложные объекты **пошагово**. Отделяет конструирование объекта от его представления.
    *   **Простая аналогия:** **Сборка компьютера.** Вы не покупаете готовый ПК, а выбираете шаг за шагом: процессор, оперативку, видеокарту, корпус (директор использует строителя). Можно собрать и мощный игровой ПК, и дешевый офисный, используя один и тот же процесс "строительства".
    *   **Зачем?** Когда объект имеет много компонентов или сложный процесс инициализации. Позволяет создавать разные представления одного объекта.

5.  **Prototype (Прототип)**
    *   **Суть:** Создает новые объекты путем **клонирования** существующего объекта-прототипа.
    *   **Простая аналогия:** **Ксерокс.** У вас есть важный документ (прототип). Чтобы получить его точную копию, вы не перепечатываете его заново, а просто копируете на ксероксе.
    *   **Зачем?** Когда создание объекта с нуля дороже (по ресурсам или времени), чем копирование. Полезно, когда у объекта много возможных состояний.

---

### **СТРУКТУРНЫЕ (Как строить гибкие и понятные структуры из классов и объектов)**

Эти паттерны отвечают на вопрос **"КАК собрать объекты и классы в более крупные структуры"**, сохраняя гибкость и эффективность.

6.  **Adapter (Адаптер)**
    *   **Суть:** Позволяет объектам с **несовместимыми интерфейсами** работать вместе.
    *   **Простая аналогия:** **Переходник для розетки.** Ваша вилка от европейского устройства (клиент) не подходит к американской розетке (сервис). Вы используете переходник (адаптер), который "оборачивает" вилку и позволяет ей работать.
    *   **Зачем?** Чтобы интегрировать старый или сторонний код, интерфейс которого не совпадает с вашим.

7.  **Composite (Компоновщик)**
    *   **Суть:** Позволяет сгруппировать множество объектов в **древовидную структуру** и работать с ней как с единым объектом.
    *   **Простая аналогия:** **Файловая система.** Папка (композит) может содержать как файлы (листья), так и другие папки. Вы можете выполнить операцию (например, "удалить") над всей папкой, и она рекурсивно применится ко всему её содержимому.
    *   **Зачем?** Когда нужно представить иерархию "часть-целое" и единообразно работать как с отдельными объектами, так и с их группами.

8.  **Proxy (Заместитель)**
    *   **Суть:** Объект, который является **заместителем** другого объекта и контролирует доступ к нему.
    *   **Простая аналогия:** **Банковская карта (прокси) vs наличные (реальный объект).** Карта — это заместитель вашего счета. Она позволяет проводить платежи, но с дополнительным контролем (проверка PIN, лимиты, логирование), не давая прямого доступа к деньгам.
    *   **Зачем?** Для ленивой загрузки, кэширования, контроля доступа, логирования.

9.  **Flyweight (Легковес)**
    *   **Суть:** Экономит память, **разделяя** общее состояние между множеством объектов вместо хранения одинаковых данных в каждом объекте.
    *   **Простая аналогия:** **Шрифты в текстовом редакторе.** Каждая буква "А" в документе не хранит информацию о своем начертании (гарнитура, размер, цвет). Вместо этого она ссылается на общий объект "стиль А", а хранит только свои уникальные координаты на странице.
    *   **Зачем?** Когда в приложении используется огромное количество почти одинаковых объектов, и нужно экономить оперативную память.

10. **Facade (Фасад)**
    *   **Суть:** Предоставляет **простой интерфейс** к сложной системе классов, библиотеке или фреймворку.
    *   **Простая аналогия:** **Кнопка "Пуск" на кофемашине.** Внутри происходит сотня операций: помол зерен, нагрев воды, подача пара, сброс давления. Но вам, как пользователю, доступна одна простая кнопка (фасад), скрывающая всю эту сложность.
    *   **Зачем?** Чтобы упростить использование сложной подсистемы, сделать код клиента независимым от многих классов.

11. **Bridge (Мост)**
    *   **Суть:** Разделяет один или несколько классов на две отдельные иерархии — **абстракцию** и **реализацию**, позволяя изменять их независимо друг от друга.
    *   **Простая аналогия:** **Пульт (абстракция) и устройство (реализация).** У вас есть абстрактный пульт с кнопками "включить", "громче". Он может работать с разными устройствами: телевизором, радио, проектором. Вы можете менять пульты (добавить голосовое управление) и устройства независимо.
    *   **Зачем?** Чтобы избежать постоянного роста числа классов (например, `ТелевизорСПультомA`, `ТелевизорСПультомB`, `РадиоСПультомA`...).

12. **Decorator (Декоратор)**
    *   **Суть:** Динамически **добавляет** объекту новые обязанности (функциональность). Является гибкой альтернативой наследованию.
    *   **Простая аналогия:** **Одевание человека.** Человек — базовый объект. Вы можете надеть на него футболку (декоратор `Футболка`), затем пиджак (декоратор `Пиджак`), затем плащ (декоратор `Плащ`). Каждый слой добавляет новые свойства (тепло, стиль, защита от дождя), но вы не меняете сам объект "человек".
    *   **Зачем?** Чтобы добавлять функциональность объектам на лету, не создавая новых подклассов и не изменяя исходный код.

---