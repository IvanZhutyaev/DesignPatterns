# Паттерны Проектирования
Паттерны проектирования: примеры на Python

### **ПОРОЖДАЮЩИЕ (Как правильно "рождать" объекты)**

Эти паттерны отвечают на вопрос **"КАК создать объект?"**, делая процесс гибким, удобным и контролируемым.

1.  **Singleton (Одиночка)**
    *   **Суть:** Гарантирует, что у класса есть **только один экземпляр**, и предоставляет к нему глобальную точку доступа.
    *   **Простая аналогия:** **Капитан корабля**. На корабле может быть только один капитан. Когда нужно принять решение, все обращаются именно к нему, а не ищут нового.
    *   **Зачем?** Когда нужен единый контроль: настройки приложения, подключение к базе данных, логгер.

2.  **Factory Method (Фабричный метод)**
    *   **Суть:** Определяет **интерфейс** для создания объекта, но позволяет подклассам решать, какой именно класс создавать.
    *   **Простая аналогия:** **Строительная компания.** У вас есть общий план дома (интерфейс). Компания-застройщик (подкласс) решает, какие конкретно материалы и бригады использовать для его постройки (конкретный объект).
    *   **Зачем?** Когда заранее неизвестно, объект какого именно подкласса понадобится создать. Делает код независимым от конкретных классов.

3.  **Abstract Factory (Абстрактная фабрика)**
    *   **Суть:** Создает **семейства** связанных объектов, не привязываясь к их конкретным классам.
    *   **Простая аналогия:** **Мебельный гарнитур.** Вы идете не за отдельным стулом, а в магазин "Современный стиль" (абстрактная фабрика). Там вы получаете *весь комплект*: современный диван, современный стол, современный шкаф (семейство объектов). В магазине "Классический стиль" будут другие, но тоже гармонирующие между собой предметы.
    *   **Зачем?** Когда система должна быть независима от того, как создаются и компонуются её продукты, и должна работать с целыми семействами.

4.  **Builder (Строитель)**
    *   **Суть:** Позволяет создавать сложные объекты **пошагово**. Отделяет конструирование объекта от его представления.
    *   **Простая аналогия:** **Сборка компьютера.** Вы не покупаете готовый ПК, а выбираете шаг за шагом: процессор, оперативку, видеокарту, корпус (директор использует строителя). Можно собрать и мощный игровой ПК, и дешевый офисный, используя один и тот же процесс "строительства".
    *   **Зачем?** Когда объект имеет много компонентов или сложный процесс инициализации. Позволяет создавать разные представления одного объекта.

5.  **Prototype (Прототип)**
    *   **Суть:** Создает новые объекты путем **клонирования** существующего объекта-прототипа.
    *   **Простая аналогия:** **Ксерокс.** У вас есть важный документ (прототип). Чтобы получить его точную копию, вы не перепечатываете его заново, а просто копируете на ксероксе.
    *   **Зачем?** Когда создание объекта с нуля дороже (по ресурсам или времени), чем копирование. Полезно, когда у объекта много возможных состояний.

---

### **СТРУКТУРНЫЕ (Как строить гибкие и понятные структуры из классов и объектов)**

Эти паттерны отвечают на вопрос **"КАК собрать объекты и классы в более крупные структуры"**, сохраняя гибкость и эффективность.

6.  **Adapter (Адаптер)**
    *   **Суть:** Позволяет объектам с **несовместимыми интерфейсами** работать вместе.
    *   **Простая аналогия:** **Переходник для розетки.** Ваша вилка от европейского устройства (клиент) не подходит к американской розетке (сервис). Вы используете переходник (адаптер), который "оборачивает" вилку и позволяет ей работать.
    *   **Зачем?** Чтобы интегрировать старый или сторонний код, интерфейс которого не совпадает с вашим.

7.  **Composite (Компоновщик)**
    *   **Суть:** Позволяет сгруппировать множество объектов в **древовидную структуру** и работать с ней как с единым объектом.
    *   **Простая аналогия:** **Файловая система.** Папка (композит) может содержать как файлы (листья), так и другие папки. Вы можете выполнить операцию (например, "удалить") над всей папкой, и она рекурсивно применится ко всему её содержимому.
    *   **Зачем?** Когда нужно представить иерархию "часть-целое" и единообразно работать как с отдельными объектами, так и с их группами.

8.  **Proxy (Заместитель)**
    *   **Суть:** Объект, который является **заместителем** другого объекта и контролирует доступ к нему.
    *   **Простая аналогия:** **Банковская карта (прокси) vs наличные (реальный объект).** Карта — это заместитель вашего счета. Она позволяет проводить платежи, но с дополнительным контролем (проверка PIN, лимиты, логирование), не давая прямого доступа к деньгам.
    *   **Зачем?** Для ленивой загрузки, кэширования, контроля доступа, логирования.

9.  **Flyweight (Легковес)**
    *   **Суть:** Экономит память, **разделяя** общее состояние между множеством объектов вместо хранения одинаковых данных в каждом объекте.
    *   **Простая аналогия:** **Шрифты в текстовом редакторе.** Каждая буква "А" в документе не хранит информацию о своем начертании (гарнитура, размер, цвет). Вместо этого она ссылается на общий объект "стиль А", а хранит только свои уникальные координаты на странице.
    *   **Зачем?** Когда в приложении используется огромное количество почти одинаковых объектов, и нужно экономить оперативную память.

10. **Facade (Фасад)**
    *   **Суть:** Предоставляет **простой интерфейс** к сложной системе классов, библиотеке или фреймворку.
    *   **Простая аналогия:** **Кнопка "Пуск" на кофемашине.** Внутри происходит сотня операций: помол зерен, нагрев воды, подача пара, сброс давления. Но вам, как пользователю, доступна одна простая кнопка (фасад), скрывающая всю эту сложность.
    *   **Зачем?** Чтобы упростить использование сложной подсистемы, сделать код клиента независимым от многих классов.

11. **Bridge (Мост)**
    *   **Суть:** Разделяет один или несколько классов на две отдельные иерархии — **абстракцию** и **реализацию**, позволяя изменять их независимо друг от друга.
    *   **Простая аналогия:** **Пульт (абстракция) и устройство (реализация).** У вас есть абстрактный пульт с кнопками "включить", "громче". Он может работать с разными устройствами: телевизором, радио, проектором. Вы можете менять пульты (добавить голосовое управление) и устройства независимо.
    *   **Зачем?** Чтобы избежать постоянного роста числа классов (например, `ТелевизорСПультомA`, `ТелевизорСПультомB`, `РадиоСПультомA`...).

12. **Decorator (Декоратор)**
    *   **Суть:** Динамически **добавляет** объекту новые обязанности (функциональность). Является гибкой альтернативой наследованию.
    *   **Простая аналогия:** **Одевание человека.** Человек — базовый объект. Вы можете надеть на него футболку (декоратор `Футболка`), затем пиджак (декоратор `Пиджак`), затем плащ (декоратор `Плащ`). Каждый слой добавляет новые свойства (тепло, стиль, защита от дождя), но вы не меняете сам объект "человек".
    *   **Зачем?** Чтобы добавлять функциональность объектам на лету, не создавая новых подклассов и не изменяя исходный код.

---

### **ПОВЕДЕНЧЕСКИЕ (Как эффективно распределять обязанности и организовывать взаимодействие объектов)**

Эти паттерны отвечают на вопрос **"КАК объектам эффективно взаимодействовать и распределять обязанности?"**.

13. **Template Method (Шаблонный метод)**
    *   **Суть:** Определяет **"скелет" алгоритма** в базовом классе, позволяя подклассам переопределять отдельные шаги, не меняя структуру алгоритма.
    *   **Простая аналогия:** **Рецепт приготовления напитка.** Базовый алгоритм: 1. Вскипятить воду. 2. Положить основу. 3. Добавить добавки. 4. Перемешать. Для чая и кофе шаги 2 и 3 будут разными, но общий порядок (шаблон) сохраняется.
    *   **Зачем?** Чтобы избежать дублирования кода в классах, где алгоритмы схожи, но отличаются в деталях.

14. **Mediator (Посредник)**
    *   **Суть:** Вводит объект-посредник, который **централизует** общение между группой объектов. Объекты больше не общаются напрямую, а только через посредника.
    *   **Простая аналогия:** **Диспетчер аэропорта.** Пилоты самолетов (объекты) не переговариваются друг с другом напрямую ("Эй, Boeing-737, уступи мне полосу!"). Все общение идет через диспетчерскую вышку (посредник), которая координирует движение.
    *   **Зачем?** Чтобы уменьшить связанность множества классов, которые должны взаимодействовать между собой.

15. **Chain of Responsibility (Цепочка обязанностей)**
    *   **Суть:** Позволяет передавать запрос по **цепочке обработчиков**. Каждый последующий обработчик решает, может ли он обработать запрос, или передать его дальше.
    *   **Простая аналогия:** **Поддержка в компании.** Ваш запрос (проблема) проходит цепочку: 1) Автоответчик, 2) Оператор первой линии, 3) Технический специалист, 4) Менеджер. Каждое звено либо решает проблему, либо передает её "выше".
    *   **Зачем?** Когда есть более одного объекта, который может обработать запрос, и обработчик заранее неизвестен.

16. **Observer (Наблюдатель)**
    *   **Суть:** Создает механизм **подписки**, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
    *   **Простая аналогия:** **Каналы/Подписка на YouTube.** Вы (наблюдатель) подписываетесь на канал (издатель). Когда выходит новое видео (событие), все подписчики получают уведомление. Канал не знает, кто конкретно его подписчики.
    *   **Зачем?** Для реализации реактивных систем, где изменение состояния одного объекта должно автоматически уведомлять другие.

17. **Strategy (Стратегия)**
    *   **Суть:** Определяет **семейство алгоритмов**, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет менять алгоритм независимо от клиента, который его использует.
    *   **Простая аналогия:** **Навигатор в машине.** Задача — построить маршрут из А в Б (контекст). Алгоритмы (стратегии) могут быть разными: "Самый быстрый", "Самый короткий", "Объезд пробок". Вы можете менять стратегию на лету, не меняя автомобиль.
    *   **Зачем?** Когда в программе есть множество родственных классов, отличающихся только поведением.

18. **Command (Команда)**
    *   **Суть:** Инкапсулирует запрос в виде объекта, позволяя **параметризовать** клиентов с другими запросами, ставить их в очередь или поддерживать отмену операций.
    *   **Простая аналогия:** **Заказ в ресторане.** Официант (клиент) принимает заказ (объект-команда), который инкапсулирует детали ("стейк rare"). Он отдает заказ на кухню (получатель), не зная, как именно его приготовят. Заказ можно отменить до исполнения или поставить в очередь.
    *   **Зачем?** Для реализации очереди задач, отмены операций (Undo/Redo), отложенного запуска.

19. **State (Состояние)**
    *   **Суть:** Позволяет объекту **менять своё поведение** при изменении его внутреннего состояния. Создается впечатление, что объект изменил свой класс.
    *   **Простая аналогия:** **Плеер.** У него есть состояния: `Воспроизведение`, `Пауза`, `Стоп`. Нажатие одной и той же кнопки "Play" в разных состояниях приводит к разному поведению. В `Стоп` — начинает трек с начала, в `Пауза` — продолжает с того же места.
    *   **Зачем?** Когда поведение объекта сильно зависит от его состояния, и в коде много условных операторов, проверяющих это состояние.

20. **Visitor (Посетитель)**
    *   **Суть:** Позволяет добавлять **новые операции** к объектам, не изменяя классы этих объектов.
    *   **Простая аналогия:** **Страховой агент (посетитель), который приходит в компанию.** Он обходит все отделы (объекты структуры): бухгалтерия, склад, IT. Для каждого отдела он выполняет свою специфическую операцию (оценка рисков, расчет страховки), не меняя при этом работу самих отделов.
    *   **Зачем?** Когда нужно выполнить операцию над всеми элементами сложной структуры объектов (например, AST-дерево), и добавлять эту операцию прямо в классы элементов неудобно или невозможно.

21. **Interpreter (Интерпретатор)**
    *   **Суть:** Решает частый случай, когда нужно создать **язык** для решения конкретных задач, определить грамматику этого языка и интерпретатор для разбора и выполнения выражений.
    *   **Простая аналогия:** **Калькулятор или поиск по шаблону.** Вы вводите выражение "2 + 3 * 4" (предложение на языке математики). Интерпретатор разбирает его по правилам грамматики (сначала умножение, потом сложение) и вычисляет результат.
    *   **Зачем?** Для реализации простых языков, регулярных выражений, разбора форматов (например, SQL-запросов в конкретной предметной области).

22. **Iterator (Итератор)**
    *   **Суть:** Предоставляет способ **последовательного доступа** ко всем элементам составного объекта, не раскрывая его внутреннего устройства.
    *   **Простая аналогия:** **Путешествие по книге с помощью закладки.** Вы можете листать книгу (коллекцию) вперед и назад, не зная, как она устроена внутри (сколько в ней страниц, как они сшиты). Закладка (итератор) знает вашу текущую позицию.
    *   **Зачем?** Чтобы предоставить единый интерфейс для обхода любых коллекций (списки, деревья, графы).

23. **Memento (Хранитель / Снимок)**
    *   **Суть:** Позволяет **сохранять и восстанавливать** прошлые состояния объекта, не раскрывая деталей его реализации.
    *   **Простая аналогия:** **Сохранение в компьютерной игре.** Вы можете в любой момент создать снимок текущего состояния игры (уровень, здоровье, инвентарь) и сохранить его. Если проиграли, вы загружаете этот снимок, возвращая игру в прошлое состояние.
    *   **Зачем?** Для реализации механизмов отмены (Undo), сохранения и восстановления состояния, снапшотов.
